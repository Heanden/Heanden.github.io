# <center>实验一 	超声波测距实验</center>
## 一、硬件参数
​        由于超声波指向性强，能量消耗缓慢，在介质中传播的距离较远，因而超声波经常用于距离的测量，如测距仪和物位测量仪等都可以通过超声波来实现。利用超声波检测往往比较迅速、方便、计算简单、易于做到实时控制，并且在测量精度方面能达到工业实用的要求，因此在移动机器人研制上也得到了广泛的应用。压电式超声波发生器原理。
​        本实验采用的传感器是压电式超声波发生器，实际上是利用压电晶体的谐振来工作的。它有两个压电晶片和一个共振板。当它的两极外加脉冲信号，其频率等于压电晶片的固有振荡频率时，压电晶片将会发生共振，并带动共振板振动，便产生超声波。反之，如果两电极间未外加电压，当共振板接收到超声波时，将压迫压电晶片作振动，将机械能转换为电信号，这时它就成为超声波接收器了。
​        超声波测距原理：超声波发射器向某一方向发射超声波，在发射时刻的同时开始计时，超声波在空气中传播，途中碰到障碍物就立即返回来，超声波接收器收到反射波就立即停止计时。超声波在空气中的传播速度为340m/s，根据计时器记录的时间t，就可以计算出发射点距障碍物的距离(s)，即：s=340t/2 。这就是所谓的时间差测距法。

## 二、实验原理
​         本实验用NE555电路产生40KHZ的脉冲信号用来发送超声波，此信号出厂已调节，请使用时再测量和微调。接收头接收到信号后，进行了放大，滤波，整形等处理环节，可输出下降沿或者上升沿等接收信号。单片机使用1个IO口控制发射，外部中断脚接收，定时器0来计时。从而可得到从发射到接收的时间来计算障碍物的距离。附带的还有温度的采集和显示，蜂鸣器提示音，但未对超声波测距做温度补偿。

## 三、实验内容
#### 1、硬件电路
（略）见文件夹PDF或者产品说明书。

#### 2、硬件连接表

| MCU-AT89S52 | 超声波测距模块 | LCD1602字符屏 | 蜂鸣器 | DS18B20电路 |
| :---------: | :------------: | :-----------: | :----: | :---------: |
|   P00~P07   |                |    DB0~DB7    |        |             |
|     P20     |                |      RS       |        |             |
|     P21     |                |      RW       |        |             |
|     P22     |                |      EN       |        |             |
|     P10     |   发送使能H    |               |        |             |
|     P32     |    反向输出    |               |        |             |
|     P11     |                |               |  BUZ   |             |
|     P12     |                |               |        |  数字输出   |

## 四、程序

#### 1、LCDmodule.c
```c
void Delay_ms(uint n)
{
	uint i,j;
	for(i=0;i<n;i++)
		for(j=0;j<120;j++)
			;
}
/* 
函数：void delay_n40us(uint n)
功能：延时程序 
参数： 入：n  出：无  
说明： 
*/ 
void delay_n40us(uint n)
{ 
	uint i; 
    uchar j;             
    for(i=n;i>0;i--) 
    for(j=0;j<2;j++);           
}  
/* 
函数：void check_busy(void)
功能：查忙 
参数： 无  
说明： 
*/ 
void LCD_check_busy()
{                           
	 uchar btem=0xff;
	 do{	
		btem=0xff;
		LcdE=0; 
	    LcdRS=0;         
        LcdRW=1;  
        LcdE=1; 
		btem=LcdBUS;
        }
		while(btem&0x80);
		LcdE=0; 
} 
/* 
函数：void LCD_write_command(uchar cdat) 
功能：LCD写指令 
参数： 入：dat  出：无 
说明： 
*/ 
void LCD_write_command(uchar cdat) 
{ 
    LCD_check_busy();
	LcdE=0;
	LcdRS=0;//指令 
	LcdRW=0;//写入 
	LcdBUS=cdat;  
	LcdE=1;//允许 
	_nop_();
	LcdE=0; 
	Delay_ms(1);
}
/* 
函数：void LCD_write_data(uchar ddat) 
功能：LCD写数据  
参数： 入：dat  出：无 
说明： 
*/ 
void LCD_write_data(uchar ddat) 
{ 
	LCD_check_busy();
	LcdE=0;	
	LcdRS=1;//数据 
	LcdRW=0;//写入 
	LcdBUS=ddat; 
	LcdE=1;//允许
	_nop_();  
	LcdE=0; 
	Delay_ms(1); 
}
/* 
函数：void LCD_initial(void)
功能：LCD初始化 
参数： 入：无  出：无 
说明： 
*/ 
void LCD_init(void) 
{ 
	//Delay_ms(15);
	//LCD_write_command_nc(0x38);//设置8位格式，2行，5x7  不查忙
	//Delay_ms(5);
	//LCD_write_command_nc(0x38);//设置8位格式，2行，5x7 	不查忙
	//Delay_ms(5);
	//LCD_write_command_nc(0x38);//设置8位格式，2行，5x7 	不查忙
//	LCD_write_command(0x38);//设置8位格式，2行，5x7 	不查忙
//	LCD_write_command(0x08);//清除屏幕显示 
//	LCD_write_command(0x01);//清除屏幕显示 
//	LCD_write_command(0x06);//设定输入方式，光标右移 
//	LCD_write_command(0x0c);//整体显示，关光标，不闪烁 
//	delay_n40us(100);
    
	LCD_write_command(0x38);//8位总线,双行显示，5X7的点阵字符
	LCD_write_command(0x0C);//开整体显示,光标关，无黑块
	LCD_write_command(0x06);//光标右移
	LCD_write_command(0x01);//清屏
	Delay_ms(2);
}
/* 
函数：void main(void)
功能：主程序 
参数： 入：x,y,dat  
说明： 
*/ 

void LCD_disp_char(uchar x,uchar y,uchar dat) 
{ 
	uchar address; 
	if(y==1) 
    address=0x80+x; 
	else 
    address=0xc0+x; 
	LCD_write_command(address); 
	LCD_write_data(dat); 
	delay_n40us(2);
}

/* 
函数：void LCD_disp_string(uchar x,uchar y,uchar *str)
功能：字符串显示程序 
参数： 入：x,y,*str 出：无 
说明： 
*/ 
void LCD_disp_string(uchar x,uchar y,uchar *str)
{
	uchar address; 
	if(y==1) 
    {address=0x80+x;} 
	else 
    {address=0xc0+x;}
	LCD_write_command(address);	
 	while(*str>0)
	{
	LCD_write_data(*str++);
	}
 } 
```

#### 2、LCDmodule.h
```c
#ifndef _LCDmodule_H_ 
#define _LCDmodule_H_
#include <reg52.h>
#include <intrins.h>
#define uchar unsigned char
#define uint unsigned int
#define LcdBUS P0
sbit LcdRS=P2^0;
sbit LcdRW=P2^1;
sbit LcdE=P2^2;

//////////////////////////

void delay_n40us(uint n);
void LCD_check_busy();
void LCD_write_command(uchar cdat);
void LCD_write_data(uchar ddat);
void LCD_init(void);
void LCD_disp_char(uchar x,uchar y,uchar dat);
void LCD_disp_string(uchar x,uchar y,uchar *str);
#endif
```


#### 3、TEmodule.c

```c
#include "TEmodule.h"
 /*--------------精确延时5us子程序---------*/	
void delay5(uchar n)
{
	 do
	 {
	 _nop_();
	 _nop_();
	 _nop_();
	 n--;
	 }
	 while(n);
}
/*--------------初始化函数--------------------*/
void init_ds18b20(void)
{
	 uchar x=0; 
	 DQ =0;    
	 delay5(120); 
	 DQ =1;    
	 delay5(16);
	 delay5(80);
}
/*--------------读取一字节函数----------------*/
uchar readbyte(void)
{
	uchar i=0;
	uchar date=0;
	for (i=8;i>0;i--)
	 {
		  DQ =0;
		  delay5(1);
		  DQ =1;	//15微秒内拉释放总线
		  date>>=1;
		  if(DQ)
		  date|=0x80;
		  delay5(11);
	 }
 	return(date);
}
/*--------------写一字节函数------------------*/
void writebyte(uchar dat)
{
 uchar i=0;
 for(i=8;i>0;i--)
	 {
	  DQ =0;
	  DQ =dat&0x01;//写"1" 在15微秒内拉低 
	  delay5(12);	   //写"0" 拉低60微秒
	  DQ = 1;	   
	  dat>>=1;
	  delay5(5);
	  }
}
/*--------------读取温度函数------------------*/
uint TE_convert(void)
{
	uchar a,b;
	uint t;
	float tt;
	init_ds18b20();
	writebyte(0xCC); 
	writebyte(0x44);
	init_ds18b20();
	writebyte(0xCC); 
	writebyte(0xBE); 
	a=readbyte();
	b=readbyte();
	t=b;
	t<<=8;
	t=t|a;
	tt=t*0.625;
	t=tt;
	return(t);
}
```

#### 4、TEmodule.h
```c
#ifndef _TEmodule_H_ 
#define _TEmodule_H_
#include<reg52.h>
#include<intrins.h>
#define uchar unsigned char
#define  uint unsigned int
sbit DQ=P1^2;
void delay5(uchar);
void init_ds18b20(void);
uchar readbyte(void);
void writebyte(uchar);
uint TE_convert(void);
#endif
```
#### 5、main.c
```c
#include<reg52.h>
#include <intrins.h>
#include"LCDmodule.h"
#include"TEmodule.h"
#define uchar unsigned char
#define uint unsigned  int
#define U_OverTime  40       //超时时间设置 单位MS
#define U_DeadTime  30		 //盲区时间设置 单位us 距离 x*0.017cm
#define U_SendTime  150      //发送脉冲的时间 单位us
sbit 	SendPin=P1^0;        //发射使能脚
sbit    BeepPin=P1^1;
sbit 	ReceivePin=P3^2;
uint 	ReceiveTime=0;
bdata 	UFlag=0;			 //用户自定义标志位
sbit 	SendFlag=UFlag^0;
sbit 	ReceiveFlag=UFlag^1;
sbit    ReceiveGetFlag=UFlag^2;	 
void  	InitMode(void);
/**********串口模式2初始化程序*************/
void  InitMode(void)
{
	TMOD = 0x01;		  // TO 16位计时
	TH0 = 0x00 ;          //初始化为0 发送后计时
	TL0 = 0x00 ;
	SCON = 0x00;	      
	PCON =0X00;			  		
	IE=0;				  //清除中断使能寄存器
	EA=1;				  //开启中断使能
	SendPin=0;			  //不使能发射
	BeepPin=0;
}
/**********1/2nms延时子程序*************/
void Delay_HalfNms(uint n)
{
		uint i,j;
	for(i=0;i<n;i++)
    {
		for(j=0;j<70;j++)
		{;}
	}
}
/**********nms延时子程序*************/
void Delay_Nms(uint n)
{
	uint i,j;
	for(i=0;i<n;i++)
    {
		for(j=0;j<125;j++)
		{;}
	}
}
/**********nus延时子程序*************/
void Delay_Nus(uint n)
{
	uint i;
	for(i=0;i<n;i++);
}
/**********接收时间数据处理子程序*************/
void ReceiveTime_Deal()
{
	float  Distance=0;
	uint   temb,tem1000,tem100,tem10,tem1;
	Distance=ReceiveTime*0.184; 					 //液晶显示先放大10倍  
	temb=Distance;
	tem1000=temb/1000;		   //求出千位数据
	temb=temb%1000;		   	   //保留余下百位数据
	tem100=temb/100;		   //求出百位数据
	temb=temb%100;			   //保留十位数据
	tem10=temb/10;			   //求出十位数据
	tem1=temb%10;			   //求出个位数据
	LCD_disp_char(2,1,tem1000+0x30);	  //LCD显示处理
	LCD_disp_char(3,1,tem100+0x30);
	LCD_disp_char(4,1,tem10+0x30);
	LCD_disp_char(5,1,0x2e);
	LCD_disp_char(6,1,tem1+0x30);		
} 
/**********发送子程序*************/
void Send_Pulse()   //入口参数为发送脉冲的时间
{
	TR0=1;
	SendPin=1;					//启动发射脚
	SendFlag=1;
	Delay_Nus(U_DeadTime);		//盲区设置 
	EX0=1;						//开启外部中断0
	Delay_Nus(U_SendTime);		//发送脉冲时间
	SendPin=0;					//关闭发射脚			
}
/**********接收温度数据处理子程序*************/
void ReceiveTemperature_Deal()
{
	uint   temb,tem1000,tem100,tem10,tem1;   
   	temb=TE_convert();
	tem1000=temb/1000;		   //求出千位数据
	temb=temb%1000;		   	   //保留余下百位数据
	tem100=temb/100;		   //求出百位数据
	temb=temb%100;			   //保留十位数据
	tem10=temb/10;			   //求出十位数据
	tem1=temb%10;			   //求出个位数据
	LCD_disp_char(2,0,tem1000+0x30);	  //LCD显示处理
	LCD_disp_char(3,0,tem100+0x30);
	LCD_disp_char(4,0,tem10+0x30);
	LCD_disp_char(5,0,0x2e);
	LCD_disp_char(6,0,tem1+0x30);	
}
void main()
{
	uchar temdelay=0;	
	InitMode();
	TE_convert();
	LCD_init();
	LCD_disp_string(0,1,"D:   . cm");
	LCD_disp_string(0,0,"T:   . C"); 
	ReceiveTemperature_Deal();
	while(1)
	{
		Send_Pulse();
		Delay_Nms(U_OverTime); 
		if(ReceiveFlag)
		{
			ReceiveFlag=0;
			ReceiveGetFlag=1;
			SendFlag=0;
			EX0=0;				  //暂时关闭外部中断0
			TH0 = 0x00 ;          //清除计时数据
			TL0 = 0x00 ;
		}
		else
		{
			SendFlag=0;
			EX0=0;				  //暂时关闭外部中断0
			TR0=0;				  //关闭定时器计数
			TH0 = 0x00 ;          //清除计时数据
			TL0 = 0x00 ;	 
			LCD_disp_string(2,1,"over ");		 //超出接收时间未收到数据 显示超时
			Delay_Nms(100);
		}
		if(ReceiveGetFlag)		  
		{ 
			ReceiveGetFlag=0;
			ReceiveTime_Deal();
			BeepPin=1;			  //接收完成后 启动蜂鸣器报警 
			Delay_Nms(180);
			BeepPin=0; 
			temdelay=ReceiveTime/8;	 //距离越远 声音越缓 超出一定安全距离就延时一样
			//ReceiveTime=1600;	
			if(ReceiveTime<1800)
			{	
				Delay_HalfNms(temdelay);			 
			}
			else
			{
				Delay_Nms(180);
			}
		}
		ReceiveTemperature_Deal();
		//Delay_Nms(250);
	}
}
//*******外部中断程序*******//
void ExternalIN0() interrupt 0 using 0         //接收到信号 保存数据 待处理
{
	TR0=0;
	EX0=0;				  //暂时关闭外部中断0
	ReceiveFlag=1;
	SendFlag=0;
	ReceiveTime=TH0*256+TL0;
	TH0 = 0x00 ;          //清除计时数据
	TL0 = 0x00 ;
}
```
## 五、实验思考
#### 1、在测距中加入温度补偿，来提高测量距离的精度。
#### 2、考虑盲区和死区的处理方法。

